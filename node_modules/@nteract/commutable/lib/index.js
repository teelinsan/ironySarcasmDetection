"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toJS = toJS;
exports.fromJS = fromJS;
exports.parseNotebook = parseNotebook;
exports.stringifyNotebook = stringifyNotebook;
exports.createImmutableMimeBundle = exports.createImmutableOutput = exports.appendCellToNotebook = exports.appendCell = exports.removeCell = exports.insertCellAfter = exports.insertCellAt = exports.createCodeCell = exports.monocellNotebook = exports.emptyNotebook = exports.emptyMarkdownCell = exports.emptyCodeCell = void 0;

var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _freeze = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/freeze"));

var Immutable = _interopRequireWildcard(require("immutable"));

var v4 = require("./v4");

var v3 = require("./v3");

var _require = require("./structures"),
    emptyNotebook = _require.emptyNotebook,
    emptyCodeCell = _require.emptyCodeCell,
    emptyMarkdownCell = _require.emptyMarkdownCell,
    appendCell = _require.appendCell,
    monocellNotebook = _require.monocellNotebook,
    createCodeCell = _require.createCodeCell,
    appendCellToNotebook = _require.appendCellToNotebook,
    insertCellAt = _require.insertCellAt,
    insertCellAfter = _require.insertCellAfter,
    removeCell = _require.removeCell;

exports.removeCell = removeCell;
exports.insertCellAfter = insertCellAfter;
exports.insertCellAt = insertCellAt;
exports.appendCellToNotebook = appendCellToNotebook;
exports.createCodeCell = createCodeCell;
exports.monocellNotebook = monocellNotebook;
exports.appendCell = appendCell;
exports.emptyMarkdownCell = emptyMarkdownCell;
exports.emptyCodeCell = emptyCodeCell;
exports.emptyNotebook = emptyNotebook;

function freezeReviver(k, v) {
  return (0, _freeze.default)(v);
} // Expected usage of below is
// fromJS(parseNotebook(string|buffer))


function parseNotebook(notebookString) {
  return JSON.parse(notebookString, freezeReviver);
}

function fromJS(notebook) {
  if (Immutable.Map.isMap(notebook)) {
    // $FlowFixMe: isMap doesn't hint to flow that this is an Immutable
    var immNotebook = notebook;

    if (immNotebook.has("cellOrder") && immNotebook.has("cellMap")) {
      return immNotebook;
    }

    throw new TypeError("commutable was passed an Immutable.Map structure that is not a notebook");
  } // $FlowFixMe: isMap doesn't hint to flow that this is a plain Object


  var notebookJSON = notebook;

  if (notebookJSON.nbformat === 4 && notebookJSON.nbformat_minor >= 0) {
    if ((0, _isArray.default)(notebookJSON.cells) && (0, _typeof2.default)(notebookJSON.metadata) === "object") {
      return v4.fromJS(notebookJSON);
    }
  } else if (notebookJSON.nbformat === 3 && notebookJSON.nbformat_minor >= 0) {
    return v3.fromJS(notebookJSON);
  }

  if (notebookJSON.nbformat) {
    throw new TypeError("nbformat v".concat(notebookJSON.nbformat, ".").concat(notebookJSON.nbformat_minor, " not recognized"));
  }

  throw new TypeError("This notebook format is not supported");
}

function toJS(immnb) {
  var minorVersion = immnb.get("nbformat_minor", null);

  if (immnb.get("nbformat") === 4 && typeof minorVersion === "number" && minorVersion >= 0) {
    return v4.toJS(immnb);
  }

  throw new TypeError("Only notebook formats 3 and 4 are supported!");
} // Expected usage is stringifyNotebook(toJS(immutableNotebook))


function stringifyNotebook(notebook) {
  return (0, _stringify.default)(notebook, null, 2);
}

var createImmutableOutput = v4.createImmutableOutput;
exports.createImmutableOutput = createImmutableOutput;
var createImmutableMimeBundle = v4.createImmutableMimeBundle;
exports.createImmutableMimeBundle = createImmutableMimeBundle;