"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCodeCell = createCodeCell;
exports.createMarkdownCell = createMarkdownCell;
exports.createNotebook = createNotebook;
exports.appendCell = appendCell;
exports.appendCellToNotebook = appendCellToNotebook;
exports.insertCellAt = insertCellAt;
exports.insertCellAfter = insertCellAfter;
exports.removeCell = removeCell;
exports.monocellNotebook = exports.emptyNotebook = exports.defaultNotebook = exports.emptyMarkdownCell = exports.emptyCodeCell = void 0;

var _freeze = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/freeze"));

var uuidv4 = require("uuid").v4;

var Immutable = require("immutable"); // We're hardset to nbformat v4.4 for what we use in-memory


var defaultCodeCell = (0, _freeze.default)({
  cell_type: "code",
  execution_count: null,
  metadata: Immutable.Map({
    collapsed: false,
    outputHidden: false,
    inputHidden: false
  }),
  source: "",
  outputs: Immutable.List()
});
var defaultMarkdownCell = (0, _freeze.default)({
  cell_type: "markdown",
  metadata: Immutable.Map(),
  source: ""
});

function createCodeCell() {
  var cell = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultCodeCell;
  // $FlowFixMe: Immutable
  return Immutable.Map(cell);
}

function createMarkdownCell() {
  var cell = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMarkdownCell;
  // $FlowFixMe: Immutable
  return Immutable.Map(cell);
}

var emptyCodeCell = createCodeCell();
exports.emptyCodeCell = emptyCodeCell;
var emptyMarkdownCell = createMarkdownCell();
exports.emptyMarkdownCell = emptyMarkdownCell;
var defaultNotebook = (0, _freeze.default)({
  nbformat: 4,
  nbformat_minor: 4,
  metadata: new Immutable.Map(),
  cellOrder: new Immutable.List(),
  cellMap: new Immutable.Map()
});
exports.defaultNotebook = defaultNotebook;

function createNotebook() {
  var notebook = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultNotebook;
  // $FlowFixMe: Immutable
  return Immutable.Map(notebook);
}

var emptyNotebook = createNotebook();
exports.emptyNotebook = emptyNotebook;

// Intended to make it easy to use this with (temporary mutable cellOrder + cellMap)
function appendCell(cellStructure, immutableCell) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uuidv4();
  return {
    cellOrder: cellStructure.cellOrder.push(id),
    cellMap: cellStructure.cellMap.set(id, immutableCell)
  };
}

function appendCellToNotebook(immnb, immCell) {
  return immnb.withMutations(function (nb) {
    // $FlowFixMe: Fixed by making ImmutableNotebook a typed Record.
    var cellStructure = {
      cellOrder: nb.get("cellOrder"),
      // $FlowFixMe: Fixed by making ImmutableNotebook a typed Record.
      cellMap: nb.get("cellMap")
    };

    var _appendCell = appendCell(cellStructure, immCell),
        cellOrder = _appendCell.cellOrder,
        cellMap = _appendCell.cellMap;

    return nb.set("cellOrder", cellOrder).set("cellMap", cellMap);
  });
}

function insertCellAt(notebook, cell, cellID, index) {
  return notebook.withMutations(function (nb) {
    return nb.setIn(["cellMap", cellID], cell) // $FlowFixMe: Fixed by making ImmutableNotebook a typed record.
    .set("cellOrder", nb.get("cellOrder").insert(index, cellID));
  });
}

function insertCellAfter(notebook, cell, cellID, priorCellID) {
  return insertCellAt(notebook, cell, cellID, // $FlowFixMe: Fixed by making ImmutableNotebook a typed record.
  notebook.get("cellOrder").indexOf(priorCellID) + 1);
}

function removeCell(notebook, cellID) {
  return notebook.removeIn(["cellMap", cellID]).update("cellOrder", function (cellOrder) {
    return cellOrder.filterNot(function (id) {
      return id === cellID;
    });
  });
}

var monocellNotebook = appendCellToNotebook(emptyNotebook, emptyCodeCell);
exports.monocellNotebook = monocellNotebook;